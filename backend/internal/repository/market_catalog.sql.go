// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: market_catalog.sql

package repository

import (
	"context"
)

const createMarketItem = `-- name: CreateMarketItem :one
INSERT INTO "market_catalog" (item_id, buy_price, sell_price)
VALUES ($1, $2, $3)
RETURNING item_id, buy_price, sell_price
`

type CreateMarketItemParams struct {
	ItemID    int32
	BuyPrice  *int32
	SellPrice *int32
}

func (q *Queries) CreateMarketItem(ctx context.Context, arg CreateMarketItemParams) (MarketCatalog, error) {
	row := q.db.QueryRow(ctx, createMarketItem, arg.ItemID, arg.BuyPrice, arg.SellPrice)
	var i MarketCatalog
	err := row.Scan(&i.ItemID, &i.BuyPrice, &i.SellPrice)
	return i, err
}

const deleteMarketItem = `-- name: DeleteMarketItem :exec
DELETE FROM "market_catalog"
WHERE item_id = $1
`

func (q *Queries) DeleteMarketItem(ctx context.Context, itemID int32) error {
	_, err := q.db.Exec(ctx, deleteMarketItem, itemID)
	return err
}

const getMarketBuyPrice = `-- name: GetMarketBuyPrice :one

SELECT buy_price
FROM "market_catalog"
WHERE item_id = $1
`

// TODO: Add pagination?
func (q *Queries) GetMarketBuyPrice(ctx context.Context, itemID int32) (*int32, error) {
	row := q.db.QueryRow(ctx, getMarketBuyPrice, itemID)
	var buy_price *int32
	err := row.Scan(&buy_price)
	return buy_price, err
}

const getMarketItem = `-- name: GetMarketItem :one
SELECT item_id, buy_price, sell_price
FROM "market_catalog"
WHERE item_id = $1
`

func (q *Queries) GetMarketItem(ctx context.Context, itemID int32) (MarketCatalog, error) {
	row := q.db.QueryRow(ctx, getMarketItem, itemID)
	var i MarketCatalog
	err := row.Scan(&i.ItemID, &i.BuyPrice, &i.SellPrice)
	return i, err
}

const getMarketSellPrice = `-- name: GetMarketSellPrice :one
SELECT sell_price
FROM "market_catalog"
WHERE item_id = $1
`

func (q *Queries) GetMarketSellPrice(ctx context.Context, itemID int32) (*int32, error) {
	row := q.db.QueryRow(ctx, getMarketSellPrice, itemID)
	var sell_price *int32
	err := row.Scan(&sell_price)
	return sell_price, err
}

const listMarketItems = `-- name: ListMarketItems :many
SELECT item_id, buy_price, sell_price
FROM "market_catalog"
ORDER BY item_id
`

func (q *Queries) ListMarketItems(ctx context.Context) ([]MarketCatalog, error) {
	rows, err := q.db.Query(ctx, listMarketItems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MarketCatalog
	for rows.Next() {
		var i MarketCatalog
		if err := rows.Scan(&i.ItemID, &i.BuyPrice, &i.SellPrice); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const marketItemExists = `-- name: MarketItemExists :one
SELECT EXISTS (
    SELECT 1
    FROM "market_catalog"
    WHERE item_id = $1
) AS exists
`

func (q *Queries) MarketItemExists(ctx context.Context, itemID int32) (bool, error) {
	row := q.db.QueryRow(ctx, marketItemExists, itemID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateMarketItem = `-- name: UpdateMarketItem :one
UPDATE "market_catalog"
SET buy_price = $2,
    sell_price = $3
WHERE item_id = $1
RETURNING item_id, buy_price, sell_price
`

type UpdateMarketItemParams struct {
	ItemID    int32
	BuyPrice  *int32
	SellPrice *int32
}

func (q *Queries) UpdateMarketItem(ctx context.Context, arg UpdateMarketItemParams) (MarketCatalog, error) {
	row := q.db.QueryRow(ctx, updateMarketItem, arg.ItemID, arg.BuyPrice, arg.SellPrice)
	var i MarketCatalog
	err := row.Scan(&i.ItemID, &i.BuyPrice, &i.SellPrice)
	return i, err
}
